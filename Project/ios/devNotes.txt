Использование AVAudioPlayer vs AVPlayer vs AVQueuePlayer

Задача стояла сделать простой базовый плеер без лишних зависимостей и pod'ов.
Он должен уметь переключать их в контексте приложения, Command Center и в фоне (приложение свернуто или устройство заблокировано). Взаимодействие с очередью треков допустимо сделать как свое кастомное, так и нативное (массив AVPlayerItem)

Аспекты использования AVAudioPlayer:
+ Относительно простой доступ к необходимым полям и данным и их изменению (состояния плеера, текущее время трека итд)
+ Беспроблемная работа в контексте приложения
+ Беспроблемная работа в фоновом режиме (через его делегат с методом завершения проигрывания дорожки или через Command Center)
+ Несложная инициализация плеера для нового трека (даем либо Data объект трека или ссылку URL на локальный объект)
+- Нет поддержки очереди треков. В зависимости от ситуации может быть или плюсом, или минусом
- Есть небольшие расхождения между текущим временем трека между самим плеером и Command Center. Нельзя как-то уменьшить эти расхождения
- Не умеет из коробки в remote source media (remote URL). Это выливается в необходимость делать свой загрузчик трека
- Нельзя запустить проигрывание, пока полностью весь трек не подгрузится из сети. Если есть wi-fi всегда, то относительно незаметны моменты переключения на следующий или предыдущий трек в очереди. Пожалуй, это самый главный минус
Итог: Отличное решение для локальных треков, с remote сразу проседает качество в виде долгих прогрузок треков (5-10 секунд на прогрузку при wi-fi, 12-25 секунд при сотовой сети 3G)

Аспекты использования AVPlayer:
+ Беспроблемная работа в контексте приложения
+ Из коробки может работать с remote source media (через AVPlayerItem, к которому указан URL)
+ Беспроблемная работа в фоне из Command Center
+ Нет необходимости переинициализировать плеер при установке нового трека
+ Проигрывание трека может начинаться почти сразу при команде проигрывания при установлении флага в плеере automaticallyWaitsToMinimizeStalling в false (Ожидание проигрывания, пока не загрузится трек, если в двух словах)
+ Несмотря на расхождения между текущим временем трека между самим плеером и Command Center, можно его минимизировать определенным образом
+- В сравнении с AVAudioPlayer, доступ к необходимым полям и данным и их изменению затруднен, но возможен (например, нет простого поля isPlaying, как в AVAudioPlayer, но по косвенным признакам [timeControlStatus == .playing || (rate != 0 && error == nil)] можно узнать, проигрывается ли трек, итд)
+- Нет поддержки очереди треков. В зависимости от ситуации может быть или плюсом, или минусом
+- По сравнению с AVAudioPlayer, нет делегата с методом завершения проигрывания трека. Но оттрекать данное событие возможно через Notification Center по событию 'AVPlayerItemDidPlayToEndTime', где параметром объекта будет текущий AVPLayerItem плеера. Важный нюанс: при каждой инициализации нового трека для плеера надо подписываться на это событие и при завершении проигрывания отписываться от него
- !Минус исключительно в рамках данной ситуации! Тем не менее, это распространенная проблема: проигрывание прекращается при завершении проигрывания трека в фоне (приложение свернуто или устройство заблокировано), когда по коду идет команда на проигрывание следующего трека (через Notification Center по событию 'AVPlayerItemDidPlayToEndTime'). Фоновые операции, не связанные с управлением треками (получение прямой ссылки из сети в моем случае), приостанавливаются, пока пользователь либо не зайдет в приложение, либо через Command Center не нажмет проигрывание трека. На данный момент костыльное решение такое в данной ситуации: при инициализации проигрывания трека отправлять команду получения прямой ссылки как background task и результат передавать в main. Минус решения - зависимость от качества соединения с интернетом, так как iOS дает лишь небольшой отрезок времени для фоновых задач и его может не хватить для загрузки данных и парсинга ссылки.
Итог: Очень достойная альтернатива, которая уже может работать и с remote url, если только грамотно разобраться с проблемой переключения треков при завершении проигрывания текущего

Аспекты использования AVQueuePlayer:
+ Все плюсы AVPlayer
+ Есть поддержка очередей треков. Использование этой очереди решает главный минус AVPlayer, связанный с приостановкой проигрывания в фоне с оговорками
+- В сравнении с AVAudioPlayer, доступ к необходимым полям и данным и их изменению затруднен, но возможен (например, нет простого поля isPlaying, как в AVAudioPlayer, но по косвенным признакам [timeControlStatus == .playing || (rate != 0 && error == nil)] может узнать, проигрывается ли трек, итд)
- !Минус исключительно в рамках данной ситуации! плеер изначально надо инициализировать сразу со всеми треками в очереди с уже загруженными прямыми ссылками на треки. Это выливается в то, что загрузка и парсинг всех ссылок может занять определенное время. Плюс сервер может забанить такой ход конем, как подозрительный и выдать тайм-аут ожидания на загрузку новых ссылок. Как вариант, можно грузить порционно, но тогда остается проблема как и в AVPlayer с приостановкой проигрывания в фоне (если очередь кончилась, то не получится прогрузить ее дальше)
- Не очень гибкое управление массивом треков в очереди плеера. Доступны лишь команды проигрывания следующего трека в очереди, вставка нового трека в определенной позиции, удаление всех треков и установка новой очереди треков. Можно реализовать на их базе и другие команды (удаление определенного трека из очереди, запуск произвольного трека в очереди, проигрывание предыдущего трека и другие) под нужды, но ИМХО реализовывать их - тот еще геморрой, плюс обязательно должна быть уже своя кастомная очередь в дополнение, с которой будут браться исходные данные. Плюс стоит задача синхронизации данных из своей очереди и очереди плеера, что вряд ли решится парой строчек кода.
Итог: AVPlayer на стероидах со своей очередью. Если заморочиться и написать свой framework под этот плеер с широким перечнем функций работы с очередью, то можно использовать. Но в данной ситуации по определенным причинам не годится для использования

